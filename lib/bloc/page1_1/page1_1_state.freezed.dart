// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'page1_1_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$Page1StateTearOff {
  const _$Page1StateTearOff();

// ignore: unused_element
  _page1StateLoading loading() {
    return const _page1StateLoading();
  }

// ignore: unused_element
  _page1StateCalculate calculate() {
    return const _page1StateCalculate();
  }

// ignore: unused_element
  _page1StateError error() {
    return const _page1StateError();
  }
}

/// @nodoc
// ignore: unused_element
const $Page1State = _$Page1StateTearOff();

/// @nodoc
mixin _$Page1State {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult calculate(),
    @required TResult error(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult calculate(),
    TResult error(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_page1StateLoading value),
    @required TResult calculate(_page1StateCalculate value),
    @required TResult error(_page1StateError value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_page1StateLoading value),
    TResult calculate(_page1StateCalculate value),
    TResult error(_page1StateError value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $Page1StateCopyWith<$Res> {
  factory $Page1StateCopyWith(
          Page1State value, $Res Function(Page1State) then) =
      _$Page1StateCopyWithImpl<$Res>;
}

/// @nodoc
class _$Page1StateCopyWithImpl<$Res> implements $Page1StateCopyWith<$Res> {
  _$Page1StateCopyWithImpl(this._value, this._then);

  final Page1State _value;
  // ignore: unused_field
  final $Res Function(Page1State) _then;
}

/// @nodoc
abstract class _$page1StateLoadingCopyWith<$Res> {
  factory _$page1StateLoadingCopyWith(
          _page1StateLoading value, $Res Function(_page1StateLoading) then) =
      __$page1StateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$page1StateLoadingCopyWithImpl<$Res>
    extends _$Page1StateCopyWithImpl<$Res>
    implements _$page1StateLoadingCopyWith<$Res> {
  __$page1StateLoadingCopyWithImpl(
      _page1StateLoading _value, $Res Function(_page1StateLoading) _then)
      : super(_value, (v) => _then(v as _page1StateLoading));

  @override
  _page1StateLoading get _value => super._value as _page1StateLoading;
}

/// @nodoc
class _$_page1StateLoading implements _page1StateLoading {
  const _$_page1StateLoading();

  @override
  String toString() {
    return 'Page1State.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _page1StateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult calculate(),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult calculate(),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_page1StateLoading value),
    @required TResult calculate(_page1StateCalculate value),
    @required TResult error(_page1StateError value),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_page1StateLoading value),
    TResult calculate(_page1StateCalculate value),
    TResult error(_page1StateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _page1StateLoading implements Page1State {
  const factory _page1StateLoading() = _$_page1StateLoading;
}

/// @nodoc
abstract class _$page1StateCalculateCopyWith<$Res> {
  factory _$page1StateCalculateCopyWith(_page1StateCalculate value,
          $Res Function(_page1StateCalculate) then) =
      __$page1StateCalculateCopyWithImpl<$Res>;
}

/// @nodoc
class __$page1StateCalculateCopyWithImpl<$Res>
    extends _$Page1StateCopyWithImpl<$Res>
    implements _$page1StateCalculateCopyWith<$Res> {
  __$page1StateCalculateCopyWithImpl(
      _page1StateCalculate _value, $Res Function(_page1StateCalculate) _then)
      : super(_value, (v) => _then(v as _page1StateCalculate));

  @override
  _page1StateCalculate get _value => super._value as _page1StateCalculate;
}

/// @nodoc
class _$_page1StateCalculate implements _page1StateCalculate {
  const _$_page1StateCalculate();

  @override
  String toString() {
    return 'Page1State.calculate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _page1StateCalculate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult calculate(),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return calculate();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult calculate(),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (calculate != null) {
      return calculate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_page1StateLoading value),
    @required TResult calculate(_page1StateCalculate value),
    @required TResult error(_page1StateError value),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return calculate(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_page1StateLoading value),
    TResult calculate(_page1StateCalculate value),
    TResult error(_page1StateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (calculate != null) {
      return calculate(this);
    }
    return orElse();
  }
}

abstract class _page1StateCalculate implements Page1State {
  const factory _page1StateCalculate() = _$_page1StateCalculate;
}

/// @nodoc
abstract class _$page1StateErrorCopyWith<$Res> {
  factory _$page1StateErrorCopyWith(
          _page1StateError value, $Res Function(_page1StateError) then) =
      __$page1StateErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$page1StateErrorCopyWithImpl<$Res>
    extends _$Page1StateCopyWithImpl<$Res>
    implements _$page1StateErrorCopyWith<$Res> {
  __$page1StateErrorCopyWithImpl(
      _page1StateError _value, $Res Function(_page1StateError) _then)
      : super(_value, (v) => _then(v as _page1StateError));

  @override
  _page1StateError get _value => super._value as _page1StateError;
}

/// @nodoc
class _$_page1StateError implements _page1StateError {
  const _$_page1StateError();

  @override
  String toString() {
    return 'Page1State.error()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _page1StateError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult calculate(),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return error();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult calculate(),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_page1StateLoading value),
    @required TResult calculate(_page1StateCalculate value),
    @required TResult error(_page1StateError value),
  }) {
    assert(loading != null);
    assert(calculate != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_page1StateLoading value),
    TResult calculate(_page1StateCalculate value),
    TResult error(_page1StateError value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _page1StateError implements Page1State {
  const factory _page1StateError() = _$_page1StateError;
}
